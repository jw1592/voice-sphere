<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voice Sphere</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none; /* 모바일에서 기본 터치 동작 비활성화 */
            -webkit-touch-callout: none; /* iOS에서 길게 터치할 때 메뉴 비활성화 */
            -webkit-user-select: none; /* 텍스트 선택 비활성화 */
            user-select: none;
        }
        canvas {
            display: block;
        }
        #audio-player {
            display: none;
        }
    </style>
    <!-- Firebase SDK 추가 -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.175.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.175.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <audio id="audio-player" loop>
        <source src="assets/audio/background.mp3" type="audio/mp3">
        브라우저가 오디오를 지원하지 않습니다.
    </audio>

    <script type="module">
        // Firebase 초기화
        const firebaseConfig = {
            apiKey: "AIzaSyCzKb2jHf-VjfKc2st_S2o-wIygY9QLIlk",
            authDomain: "voice-sphere-48812.firebaseapp.com",
            projectId: "voice-sphere-48812",
            storageBucket: "voice-sphere-48812.firebasestorage.app",
            messagingSenderId: "712806442728",
            appId: "1:712806442728:web:99b72fac44bcca1969cb5d",
            databaseURL: "https://voice-sphere-48812-default-rtdb.asia-southeast1.firebasedatabase.app"
        };
        
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        import * as THREE from 'three';
        import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

        // Three.js 설정
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // TrackballControls 추가
        const controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 3.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = true;
        controls.staticMoving = false;
        controls.dynamicDampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 10;
        controls.target = new THREE.Vector3(0, 0, 0);

        // 모바일 터치 이벤트 방지
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        // 더블탭 줌 방지
        document.addEventListener('dblclick', function(e) {
            e.preventDefault();
        }, { passive: false });

        // 점들로 구성된 스피어 생성
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 3000;
        const positions = new Float32Array(particlesCount * 3);
        const colors = new Float32Array(particlesCount * 3);
        const radius = 2;

        for(let i = 0; i < particlesCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // 초기 색상 설정 (녹색)
            colors[i * 3] = 0;     // R
            colors[i * 3 + 1] = 1; // G
            colors[i * 3 + 2] = 0; // B
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.02,
            vertexColors: true, // 정점 색상 사용
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // 카메라 위치 초기화 함수
        function resetCameraPosition() {
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        // 창 크기 조절 시 카메라 위치 재설정
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            controls.handleResize();
            resetCameraPosition();
        }

        // 창 크기 조절 이벤트 리스너 추가
        window.addEventListener('resize', onWindowResize, false);

        // 초기 카메라 위치 설정
        resetCameraPosition();

        // 랜덤 회전 속도 설정
        const rotationSpeed = {
            x: (Math.random() - 0.5) * 0.001,
            y: (Math.random() - 0.5) * 0.001,
            z: (Math.random() - 0.5) * 0.001
        };

        // 마우스 휠 이벤트
        let particleSize = 0.02;
        window.addEventListener('wheel', (event) => {
            particleSize = Math.max(0.01, Math.min(0.05, particleSize + event.deltaY * -0.0001));
            particlesMaterial.size = particleSize;
        });

        // 애니메이션
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // 자동 회전
            particlesMesh.rotation.x += rotationSpeed.x;
            particlesMesh.rotation.y += rotationSpeed.y;
            particlesMesh.rotation.z += rotationSpeed.z;
            
            renderer.render(scene, camera);
        }

        animate();

        // 오디오 재생 함수
        const audioPlayer = document.getElementById('audio-player');
        let hasInteracted = false;

        function startAudio() {
            if (!hasInteracted) {
                hasInteracted = true;
                audioPlayer.volume = 0.5;
                audioPlayer.play().catch(error => {
                    console.log("오디오 재생 실패:", error);
                });
            }
        }

        // 모든 사용자 상호작용에서 오디오 시작
        renderer.domElement.addEventListener('click', startAudio, { once: true });
        renderer.domElement.addEventListener('touchstart', startAudio, { once: true });
        renderer.domElement.addEventListener('mousedown', startAudio, { once: true });

        // 페이지 visibility 변경 시 오디오 처리
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                audioPlayer.pause();
            } else if (hasInteracted) {
                audioPlayer.play().catch(error => {
                    console.log("오디오 재생 실패:", error);
                });
            }
        });

        // 사용자에게 안내 메시지 표시
        const message = document.createElement('div');
        message.style.position = 'fixed';
        message.style.bottom = '20px';
        message.style.left = '50%';
        message.style.transform = 'translateX(-50%)';
        message.style.color = '#00ff00';
        message.style.fontSize = '16px';
        message.style.fontFamily = 'Arial, sans-serif';
        message.style.padding = '10px';
        message.style.background = 'rgba(0, 0, 0, 0.5)';
        message.style.borderRadius = '5px';
        message.style.pointerEvents = 'none';
        message.textContent = '화면을 클릭하면 음악이 재생됩니다';
        document.body.appendChild(message);

        // 5초 후 메시지 숨기기
        setTimeout(() => {
            message.style.opacity = '0';
            message.style.transition = 'opacity 1s';
            setTimeout(() => message.remove(), 1000);
        }, 5000);

        // Raycaster 설정
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // 마우스 클릭 이벤트 처리
        function onMouseClick(event) {
            // 마우스 좌표를 정규화된 장치 좌표로 변환
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Raycaster 업데이트
            raycaster.setFromCamera(mouse, camera);

            // 점들과의 교차 검사
            const intersects = raycaster.intersectObject(particlesMesh);

            if (intersects.length > 0) {
                const index = intersects[0].index;
                console.log('클릭한 점 인덱스:', index);
                
                // Firebase에서 점의 현재 상태 확인
                database.ref('points/list/' + index).once('value')
                    .then((snapshot) => {
                        const pointData = snapshot.val();
                        // 점이 비어있으면 차지
                        if (!pointData || !pointData.isOccupied) {
                            return database.ref('points/list/' + index).set({
                                isOccupied: true,
                                userId: 'temporary-user-id' // 나중에 실제 사용자 ID로 대체
                            });
                        }
                    })
                    .then(() => {
                        // 점 색상 변경
                        const colors = particlesMesh.geometry.attributes.color.array;
                        colors[index * 3] = 1;    // R
                        colors[index * 3 + 1] = 0;// G
                        colors[index * 3 + 2] = 0;// B
                        particlesMesh.geometry.attributes.color.needsUpdate = true;
                    })
                    .catch((error) => {
                        console.error('점 업데이트 중 에러:', error);
                    });
            }
        }

        // 클릭 이벤트 리스너 추가
        renderer.domElement.addEventListener('click', onMouseClick);

        // Firebase 실시간 업데이트 감지
        database.ref('points/list').on('child_changed', (snapshot) => {
            const index = parseInt(snapshot.key);
            const pointData = snapshot.val();
            
            // 색상 배열 업데이트
            const colors = particlesMesh.geometry.attributes.color.array;
            if (pointData.isOccupied) {
                colors[index * 3] = 1;     // R (빨간색)
                colors[index * 3 + 1] = 0; // G
                colors[index * 3 + 2] = 0; // B
            } else {
                colors[index * 3] = 0;     // R
                colors[index * 3 + 1] = 1; // G (녹색)
                colors[index * 3 + 2] = 0; // B
            }
            particlesMesh.geometry.attributes.color.needsUpdate = true;
        });
    </script>
</body>
</html> 